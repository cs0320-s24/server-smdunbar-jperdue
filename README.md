# Project Details
This server contains two major functionalities, one which allows users to upload, view, and search CSV files, the other allowing them to query Census Data for Broadband connectivity given a county and state. 

The CSV endpoints are designed to allow one CSV to be uploaded at a time, which is parsed upon upload. Once the CSV, as well as the headers boolean and filepath are saved in the server state, users can utilize the viewcsv and searchcsv, which will send serialized json responses. If no CSV has been loaded via the loadcsv endpoint, searchcsv and viewcsv will fail. Both responses will contain a result field, and if a success response is return it will include a data field with the 2D list containing the result data. If this is a search it will be the search result, and view will return the entire CSV data. Failed responses will contain a message explaining the error. 

The broadband endpoint takes in a Datasource that implements ACSDatasource interface. This allows for the developer to pass in any Datasource (mock or real). Depending on the source passed in, the broadbandHandler will query the parameters for state and county and send them into the datasource's getBroadband method to receive a string or broadband information. We implemented a CachingCensusData class that implemented ACSDatasource to act as a proxy for the real CensusAPI that cached responses that were loaded. What is returned to the user through the server are the inputted parameters and the broadband percentage.

# Design Choices
For the CSV endpoints, we developed the handler methods to pull from a given server state that each handler is constructed with. By having all handlers interact with the same state, we can ensure endpoints that rely on others, like search and view requiring a csv be loaded, can throw the necessary errors if certain precursor steps have not been taken by the user. Additionally, we used different classes for success and failure responses for each handler, to accommodate the different kinds of results a success or failure should yield (a data result for success, while an error message for failure). Then, we serialized with a serialize method within each response, allowing each handle method to return a response object that was a standard serialized json. When designing the server state which all csv handlers rely upon, we had the constructor do nothing, allowing for the assignment of values in the load handler. This choice means that the state can only be modified in the load handler, ensuring data is only loaded when the loadcsv endpoint is called, and not in the creation of the server or at any other moment. 

For broadband, we created a Codes class that is the super class to the StateCodes class and CountyCodes class. These classes make it possible to only query the database once for the State and County codes and save them in a map for later use. Then, we made an interface ACS Datasource to represents different types of datasources to take broadband information from. This allows for the use of mock and real data in testing. 

# Errors/Bugs

# Tests
For testing the CSV endpoints, we largely relied on integration testing to ensure the functionality of our server. There are unit tests which test the parse and search classes to check edge cases and functionality of the search and parse which our csv endpoints are built on, but the majority of our testing is integration testing to check possible interactions with the server. This includes interactions between different handlers, and ensures all errors return a failure response. There are also unit tests examining functionality of the serialize method, ensuring the map provided is returned as a string serialized with the json adapter.

For broadband testing, because the handler requires data from the ACS api, we utilized mock data to avoid api calls when testing. We check to ensure the cache works to store the previous requests and responses. We also ensure that the maximum items and time figures work.

# How to
First, run the server and navigate to the host location provided given your port number. 

For CSV endpoints, first use loadcsv to input data into the server state. This can be done by following the input /loadcsv?filepath=desiredpath&headers=boolean, with desired path being your chosen path and headers being true if the csv contains headers and false otherwise. Once data is successfully loaded, one can view the CSV data by following the viewcsv endpoint where the data will be contained in the data field of the response map. Similarly, one can use the search endpoint with the following input /searchcsv?query=query&column=column with query being the item to search for in the rows of the csv and the column field being either an index or column name to search within. Note that the index is an option field, but if provided the search will only yield results where the query is found within that column for every given row. 

For broadband, use the broadband endpoint and enter the state and county names that you want the broadband for. For example, this can be done with  the following request: /broadband?state=California&county=Orange%20County
